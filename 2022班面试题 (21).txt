4月27日面试题
-------------------------------------------------------------------------------------------------------------------------------------------------
1.HTML5的页面结构同HTML4或者更前的HTML有什么区别？
答：一个典型的WEB页面包含头部，脚部，导航，中心区域，侧边栏。现在如果我们想在在HTML4的HTML区域中呈现这些内容，我们可能要使用DIV标签。
但是在HTML5中通过为这些区域创建元素名称使他们更加清晰，也使得你的HTML更加可读
以下是形成页面结构的HTML5元素的更多细节：（注意主要考的是标签语意化）
    <header>：代表HTML的头部数据
    <footer>：页面的脚部区域
    <nav>：页面导航元素
    <article>：自包含的内容
    <section>：使用内部article去定义区域或者把分组内容放到区域里
    <aside>：代表页面的侧边栏内容

2.HTML静态页面出现中文乱码如何解决？
答：<meta charset="UTF-8" />

4月28日面试题
-------------------------------------------------------------------------------------------------------------------------------
1.块属性标签与行属性标签的区别？哪些标签是块属性的，哪些是行的?
答：在标准文档流里面，块级元素具有以下特点：
      ①总是在新行上开始，占据一整行；  
      ②高度，行高以及外边距和内边距都可控制；
      ③宽如果不设置,默认是父级的宽度，与内容无关；
      ④它可以容纳内联元素和其他块元素。

      行内元素的特点：
      ①和其他元素都在一行上； 
      ②高，行高及外边距和内边距部分可改变；
      ③宽度只与内容有关；
      ④行内元素只能容纳文本或者其他行内元素。
      不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，
      也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用

4月29日
-----------------------------------------------------------------------------------------------------------------------------------------------
1.清除浮动的方法
答：1.使用空标签清除浮动。这种方法是在所有浮动标签后面添加一个空标签定义css clear:both.弊端就是增加了无意义标签。
      2.使用overflow。给包含浮动元素的父标签添加css属性overflow:auto;zoom:1;zoom:1用于兼容IE6。
      3.使用after伪对象清除浮动。该方法只适用于非IE浏览器。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置height:0，否则该元素会比实际高出若干像素；
         二、content属性是必须的，但其值可以为空，content属性的值设为”.”，空亦是可以的。
      4.给浮动元素的父元素设置固定的高度
      5.使用befor和after双伪元素清除浮动（扩展内容）

2.前端页面有哪三层构成，分别是什么？作用是什么？
答：分成：结构层、表示层、行为层。
      结构层由 HTML 或 XHTML之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样一种语义：“这是一个文本段。”
      表示层由 CSS 负责创建。 CSS对“如何显示有关内容”的问题做出了回答。
      行为层负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM主宰的领域。

4月30日
-------------------------------------------------------------------------------------------------------------------------------------------------
1.浅谈一下闭包
答：闭包：有权访问函数的局部变量的函数
      闭包优点：避免全局污染
      闭包缺点：造成内存泄漏 (内存泄漏：本应该释放内存，而不能释放)
      创建闭包：外层函数创建一个受保护的局部变量
                      内层函数操作外层函数的局部变量
	      外层函数将内层函数返回到外部
	      内层函数在外部反复调用

      闭包的外层函数调用几次，就创建几个受保护的局部变量副本
      闭包的形成：由于内层函数在外部被调用，而内层函数内部引用外层函数的局部变量，导致外层函数的局部变量无法释放，从而形成了闭包

2.一个CSS文件如果过大的话，加载会很慢，占用过大带宽，如果解决？
答：1、将CSS文件拆分多个CSS文件
       2、压缩css
       3、去取冗余的样式
       4、减少css选择器层级

5月6日
----------------------------------------------------------------------------------------------------------------------------------------------
1. 事件委托是什么 
答：符合 W3C 标准的事件绑定 addEventLisntener /attachEvent 让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！
事件委托的优点:
a.提高性能:每一个函数都会占用内存空间，只需添加一个事件处理程序代理所有事件,所占用的内存空间更少。
b.动态监听:使用事件委托可以自动绑定动态添加的元素,即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。

2. 列出 display 的值，说明他们的作用。position 的值， relative 和 absolute 定位原点是？ 
答：block 块类型元素一样显示。 
      none 缺省值。向行内元素类型一样显示。 
      inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。
      list-item 象块类型元素一样显示，并添加样式列表标记。
      position 的值 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 
      fixed （老 IE 不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 
      relative 生成相对定位的元素，相对于其正常位置进行定位。 
      static 默认值。没有定位，元素出现在正常的流中 （忽略 top, bottom, left, right z-index 声明）。
      inherit 规定从父元素继承 position 属性的值。

5月7日
----------------------------------------------------------------------------------------------------------------------------------------------------
1. 面向对象以及原型
答：面向对象：将需求抽象成一个对象，然后对其成员进行分析
      面向对象三大特征：封装、继承、多态
      面向对象的第一步是创建构造函数，第二步通过构造函数创建对象实例
      原型：对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象，由于原型本身也是对象，又有自己的原型，所以形成了一条原型链。
                函数的原型是 prototype
                对象的原型是 __proto__
                对象的顶级原型为null， 即Object.prototype.__proto__ == null

2.浏览器的渲染页面机制
答：浏览器解析HTML文档和CSS样式表构建DOM树和和CSSOM树(没有设置节点外观样式)
      浏览器结合DOM树和CSSOM树构建渲染树(重绘元素)
      浏览器在渲染树内对每个渲染元素进行布局处理，计算出每一个元素的大小和位置(回流元素)
      遍历渲染树将实际的像素显示到屏幕(确认最终的回流元素样式)

5月8日
------------------------------------------------------------------------------------------------------------------------------------------------
1. $(function() {}) 和 window.onload区别
答：$(function() {})：页面html,css,js等资源加载完成后触发
      window.onload：页面html,css,js,图片等资源加载完成后触发

2.重绘和回流
答：重绘
	当页面的元素需要更新属性，新的属性对元素的外观，风格的产生影响，这个更新的过程称为重绘
	比如设置元素的background，color等等，都会重绘元素
      回流
	当页面的元素因为尺寸，位置、布局，隐藏等改变而需要浏览器重新构建的过程，这个重构的过程称为回流
	比如设置元素的width，height，float，position等等，都会回流元素

5月9日
----------------------------------------------------------------------------------------------------------------------------------------------------
1.typeof与instanceof的区别？
答：typeof 返回值是一个字符串，用来说明变量的数据类型
      typeof 一般只能返回 number,boolean,string,function,object,undefined,symbol
      typeof 不能用于判断 null, {}, []

      instanceof 用于判断一个变量是否属于某个对象的实例

2.js继承常用有哪些继承方式？
答：类式继承：子构造函数的原型对象继承父构造函数以及父构造函数的原型
      构造函数式继承：子构造函数继承父构造函数，不能继承父构造函数的原型
      组合式继承：类式继承 + 构造函数式继承
      多继承：子构造函数继承多个父构造函数

5月11日
--------------------------------------------------------------------------------------------------------------------------------------------------
1.创建ajax的四个步骤、ajax的状态码、ajax的优点
答：创建ajax的四个步骤
		创建ajax对象
		监听ajax对象请求的状态变化
		建立服务连接
		发起请求
      ajax的状态码
	               0: 请求未初始化
                               1: 已发送请求
                               2: 已接收请求
                               3: 请求处理中
                               4: 请求完成并且已响应
      ajax的优点：在不刷新整个页面情况下，可以局部更新数据

2.函数节流和函数防抖
答：函数节流：限制一个函数在一定时间内只能执行一次
      函数防抖：触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行的等待时间
      函数防抖使用场景: 
		实时搜索 比如 oninput事件
		改变窗口大小: 比如 onresize事件
		滚动：比如 onscroll

5月12日
-----------------------------------------------------------------------------------------------------------------------------------------------
1.内部插入节点和外部插入节点
答：内部插入节点，节点关系为父子关系
		在父节点尾部添加一个子节点
		父节点.append(子节点)
		子节点.appendTo(父节点)

		在父节点顶部添加一个子节点
		父节点.prepend(子节点)
		子节点.prependTo(父节点)
      外部插入节点，节点关系为同胞节点
		在节点前面添加节点
		节点1.before(节点2);
		节点2.insertBefore(节点1);

		在节点后面添加节点
		节点1.after(节点2);
		节点2.insertAfter(节点1);

2.$(this)和this关键字在jQuery中有何不同？
答：$(this)返回一个jQuery对象，可以调用jQuery方法，比如用text()获取文本
      而this代表当前元素，是JavaScript关键词中的一个，表示上下文中的当前DOM元素，不能调用jQuery 方法，直到被$()函数包裹，例如$(this)

5月13日
----------------------------------------------------------------------------------------------------------------------------------------------
1.Flash、Ajax各自的优缺点，在使用中如何取舍？
答：Flash ajax对比
      (1)Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。
      (2)ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
      共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM

2.解释jsonp的原理，以及为什么不是真正的ajax？
答：①. jsonp的原理:就是利用浏览器可以动态地插入一段js并执行的特点完成的。
      ②.为什么不是真正的 ajax?    
          ajax的核心是 ： 通过XmlHttpRequest获取非本页内容，
          jsonp的核心 ： 动态添加<script>标签来调用服务器提供的js脚本。
      ③ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；
      还是有不同点的：
      ④. 实质不同
　        ajax的核心是通过xmlHttpRequest获取非本页内容
　        jsonp的核心是动态添加script标签调用服务器提供的js脚本
      ⑤. ajax通过服务端代理一样跨域
        　jsonp也并不排斥同域的数据的获取
      ⑥ .jsonp是一种方式或者说非强制性的协议
　       ajax也不一定非要用json格式来传递数据　
      ⑦ .jsonp只支持get请求，ajax支持get和post请求
 
5月14日
---------------------------------------------------------------------------------------------------------------------------------------------
1.get与post两种方式的优缺点。
答：get:
            get是从服务器上获取数据，post是向服务器传送数据；
            get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB；
            get安全性非常低，post安全性较高。但是执行效率却比Post方法好；
            get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到；
在做数据查询时，建议用Get方式；

      post:
            post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址，用户看不到这个过程；
           所以：包含机密信息的话，建议用Post数据提交方式；而在做数据添加、修改或删除时，建议用Post方式。

2.同源策略
答：同源：协议相同，域名相同，端口相同
      不同源：只要协议、域名、端口其中之一不同，不同源就会产生跨域
      同源策略主要作用：限制不同源的服务器相互访问，提高浏览器访问网页的安全性

5月18日
------------------------------------------------------------------------------------------------------------------------------------------------
1. Http与Https的区别（关于http和https的概念大家可以自己查一下了解一下，这个问题非常常见，几乎十家公司会有七家问到）
答：①https协议需要到CA  （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)
      ②http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
      ③http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
      ④http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

2.jsonp跨域实现原理
答：创建一个script
      将请求地址赋值给script的src属性
      将后台约定回调函数名称以参数的形式挂在请求地址中
      将一个全局函数作为后台约定回调函数的值
      后台响应的数据在全部函数中处理

5月19日
-----------------------------------------------------------------------------------------------------------------------------------------------
1.请描述一下 cookies，sessionStorage 和 localStorage 的区别？
答：①localstorage和sessionstorage都是H5提供的新的存储类型，以前只有cookies来完成存储的工作。
         这两种新方式存储限制比使用cookie要大得多（至少5MB，cookie小于4k），而且速度更快。
         数据永远不会传输到服务器，只有在客户端特别要求时才能使用。
      ③通过localStorage存储的数据是永久性的：它不会过期并保留在用户的计算机上，直到Web应用程序删除它或用户要求浏览器删除它。
      ④sessionStorage与存储数据的顶级窗口或浏览器选项卡具有相同的生命周期。当选项卡永久关闭时，将删除通过sessionStorage存储的所有数据。
      ⑤localStorage和sessionStorage之间关于存储范围的差异：两种存储形式都限定在文档原点，以便具有不同来源的文档永远不会共享存储的对象。
      ⑥ sessionStorage也是基于每个窗口的范围。包含来自同一来源的文档的两个浏览器选项卡具有单独的sessionStorage数据。
          与localStorage不同，来自同一源的相同脚本在不同选项卡中打开时无法访问彼此的sessionStorage。

2.重绘和回流
答：重绘：
      当页面的元素需要更新属性，新的属性对元素的外观，风格的产生影响，这个更新的过程称为重绘
      比如设置元素的background，color等等，都会重绘元素
      回流：
      当页面的元素因为尺寸，位置、布局，隐藏等改变而需要浏览器重新构建的过程，这个重构的过程称为回流
      比如设置元素的width，height，float，position等等，都会回流元素

5月20日
-----------------------------------------------------------------------------------------------------------------------------------------------
1.讲解一下this （作用域）
答：this的指向：普通函数内的this指向全局变量
      构造函数内部this指向新创建出来的对象
      对象方法内的this指向的是调用该方法的对象
      call,apply,bind可以改变this的指向

2.px、em、rem
答：	px: 固定值
	em的值不是固定值
	em会继承父级元素的字体大小
	rem的值不是固定值
	rem会继承html元素的字体大小
	rem多数用于手机端布局

5月21日
---------------------------------------------------------------------------------------------------------------------------------------------------
1.移动端触碰屏幕事件
答：有四个触碰屏幕事件
        touchstart: 开始触碰屏幕事件
	touchmove: 触碰且在屏幕移动事件
	touchend: 离开屏幕触发事件
	touchcancel: 取消触碰事件，(发生场景：当前手机来电时)
      事件对象.targetTouches: 获取触点列表

2.bootstrap4响应式断点范围

		超大PC xl: x >= 1200px
		pc lg: x >= 992px
		平板 md: x >= 768px
		手机或者手机横屏 sm:  x >= 576px
		超小屏幕手机: x < 576

5月22日
-------------------------------------------------------------------------------------------------------------------------------------------
1.有关css属性position的属性值的描述
答：  static：没有定位，元素出现在正常的流中，占据文档流空间
      fixed：生成固定定位的元素，相对于浏览器可视窗口进行定位，不占据文档流空间
      relative：生成相对定位的元素，相对于元素本身正常位置进行定位，占据文档流空间
      absolute：生成绝对定位的元素，相对于static定位以外的第一个含有(relative, absolute, fixed, sticky)的祖先元素定位，不占据文档流空间
      sticky: 黏贴定位，相对于浏览器可视窗口进行定位，占据文档流空间

2.$.extend 和 $.fn.extend的区别
答：  $.extend
	   如果只传递一个对象，表示在jQuery构造函数扩展属性和方法，jquery实例不能使用，只能jQuery构造函数本身使用
           如果传递两个对象以上的，表示合并对象，并返回合并之后的对象
	   如果第一个参数为true，其他参数为对象时，则表示深度合并对象，并返回合并之后的对象
      $.fn.extend
	   表示在jQuery构造函数的原型prototype扩展属性和方法, jquery实例能使用, jQuery构造函数本身不能使用

5月25日
------------------------------------------------------------------------------------------------------------------------------------------------
1. jQuery的ajaxSend, ajaxSuccess, ajaxComplete的区别？
答：相同点
	ajaxSend, ajaxSuccess, ajaxComplete
	三者都是监听ajax请求状态的事件，
	需要绑定在document上，
	比如 $(document).ajaxSend(function () {})
      不同点
	ajaxSend: ajax调用send方法时执行
	ajaxSuccess：请求成功执行，回填函数的第四个参数为服务器响应的数据
	ajaxComplete：请求成功之后执行

2.渐进增强和优雅降级
答：渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验
      优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容

5月26日
-----------------------------------------------------------------------------------------------------------------------------------------------
1.js数组方法
答：concat()：合并数组，并返回合并之后的数据	
      join()：使用分隔符，将数组转为字符串并返回	
      pop()：删除最后一位，并返回删除的数据	
      shift()：删除第一位，并返回删除的数据	
      unshift()：在第一位新增一或多个数据，返回长度	
      push()：在最后一位新增一或多个数据，返回长度	 
      reverse()：反转数组，返回结果	 
      slice()：截取指定位置的数组，并返回	
      sort()：排序（字符规则），返回结果	 
      splice()：删除指定位置，并替换，返回删除的数据	
      toString()：直接转为字符串，并返回	
      valueOf()：返回数组对象的原始值	
      indexOf()：查询并返回数据的索引	
      lastIndexOf()：反向查询并返回数据的索引

5月27日
----------------------------------------------------------------------------------------------------------------------------------------------
1.js的几种遍历循环方式
答：forEach()：参数为回调函数，会遍历数组所有的项，回调函数接受三个参数，分别为value，index，self；forEach没有返回值	
      map()：同forEach，同时回调函数返回数据，组成新数组由map返回	
      every()：同forEach，同时回调函数返回布尔值，全部为true，由every返回true	
      some()：同forEach，同时回调函数返回布尔值，只要由一个为true，由some返回true

2.http部分状态码的含义
答：2开头：（请求成功）表示成功处理了请求的状态代码
      3开头：（请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向
      4开头：（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理
      5开头：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。

5月28日
-------------------------------------------------------------------------------------------------------------------------------------------
1.几种常见的http状态码的含义（以下是比较常见的，更全面的大家可以自己查一下）
答：200：成功服务器已成功处理了请求。
      203：非授权信息服务器已成功处理了请求，但返回的信息可能来自另一来源
      301：永久移动请求的网页已永久移动到新位置，即永久重定向。
      304：未修改此次请求返回的网页未修改，继续使用上次的资源。
      400：错误请求服务器无法解析该请求。
      401：未授权请求没有进行身份验证或验证未通过。
      403：禁止访问服务器拒绝此请求。
      404：未找到服务器找不到请求的网页。
      405：方法禁用服务器禁用了请求中指定的方法。
      408：请求超时服务器请求超时。
      409：冲突服务器在完成请求时发生冲突
      500：服务器内部错误服务器遇到错误，无法完成请求。
      503：服务不可用服务器目前无法使用。
      505：HTTP 版本不支持服务器不支持请求中所用的 HTTP 协议版本。

5月29日
--------------------------------------------------------------------------------------------------------------------------------------------
1.HTML5的新特性
答：(1) 绘画canvas
      (2) 用于媒介回放的video和audio元素
      (3) 本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失
      (4) sessionStorage的数据在浏览器关闭后自动删除
      (5) 语义化更好的内容元素，比如article,footer,header,nav,section

2..对WEB标准以及W3C的理解与认识？
（1）web标准规范要求，书写标签必须闭合、标签小写、不乱嵌套，可提高搜索机器人对网页内容的搜索几率；
（2）建议使用外链css和js脚本，从而达到结构与行为、结构与表现的分离，提高页面的渲染速度，能更快地显示页面的内容；
（3）样式与标签的分离，更合理的语义化标签，使内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件， 从而降低
        维护成本、改版更方便；
（4）不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性；
        遵循w3c制定的web标准，能够使用户浏览者更方便的阅读，使网页开发者之间更好的交流。

6月1日
----------------------------------------------------------------------------------------------------------------------------------------------
1.闭包是什么，有什么特性，对页面有什么影响
答：闭包简单理解就是：函数内部有嵌套定义里一个函数，内部函数调用外部函数的局部变量的时候就构成闭包。
      能保存局部变量，函数执行完不销毁。消耗内存资源

2.同步和异步的区别?
答：同步的概念应该是来自于操作系统中关于同步的概念:
      不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式)。同步强调的是顺序性，谁先谁后；异步则不存在这种顺序性。
      同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。
      异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。

6月2日
------------------------------------------------------------------------------------------------------------------------------------------------
1.var和const的区别?
答：块级作用域(ES6新增的作用域)：比如if else语句体，for语句体，switch语句体，while语句体，do while语句体
		if () {
			此处就是块级作用域
			var a = 1;
			const b = 2;
		}（上面这段打开是给大家用于理解，背的时候不用背出来，但是块级作用域是什么也要背哦）
                          var
			用于变量声明，
			可重新声明，
			可重新赋值，
			可同时声明多个变量，
			可只声明没有赋值，
			没有块级作用域，
			具有函数作用域，
			具有声明提前

	           const
			用于常量声明，
			不可重新声明，
			不可重新赋值，
			可同时声明多个常量，
			声明必须赋值，
			具有块级作用域，
			具有函数作用域，
			没有声明提前

var、let、const的区别：
① var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。

② let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。

③ const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。



6月3日
----------------------------------------------------------------------------------------------------------------------------------------------
1.call，apply，bind区别
答：call(this指向的对象, 参数1, 参数2, 参数3, ...)
      apply(this指向的对象, [参数1, 参数2, 参数3, ...])
      bind(this指向的对象, 参数1, 参数2, 参数3, ...)
      相同点：
      call，apply，bind都是函数原型的方法，都是改变函数调用时内部this的指向，第一个参数都是函数内部this指向的对象
      不同点：
	call从第二个参数开始为函数的参数，而且参数是单一传递，不能以参数数组传递;
	apply从第二个参数开始为函数的参数，而且第二个参数为数组，该数组包含函数的所有参数
	bind从第二个参数开始为函数的参数，而且参数是单一传递，不能以参数数组传递，并且返回一个绑定函数内部this指向的函数

2.使用箭头函数应注意什么？
答：（1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）
      （2）不能够使用arguments对象
      （3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误
      （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数

6月4日
---------------------------------------------------------------------------------------------------------------------------------------
1.介绍下 Set、Map的区别？
答：应用场景Set用于数据重组，Map用于数据储存
       Set：（1）成员不能重复
　　        （2）只有键值没有键名，类似数组
　　        （3）可以遍历，方法有add, delete,has
       Map:（1）本质上是健值对的集合，类似集合
　　        （2）可以遍历，可以跟各种数据格式转换

2.setTimeout、Promise、Async/Await 的区别
答：事件循环中分为宏任务队列和微任务队列
      其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行
      promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行
      async函数表示函数里面可能会有异步方法，await后面跟一个表达式
      async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行

6月5日
-------------------------------------------------------------------------------------------------------------------------------------------
1. Promise 中reject 和 catch 处理上有什么区别
答：reject 是用来抛出异常，catch 是用来处理异常
      reject 是 Promise 的方法，而 catch 是 Promise 实例的方法
      reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch
      网络异常（比如断网），会直接进入catch而不会进入then的第二个回调

2.import和export

答：ES6标准中，JavaScript原生支持模块(module)了。这种将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，
    各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。

      export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口。

      import用于在一个模块中加载另一个含有export接口的模块。

      import和export命令只能在模块的顶部，不能在代码块之中。

6月8日
---------------------------------------------------------------------------------------------------------------------------------------------
1.less和sass的区别
答：Less和Sass的主要不同就是他们的实现方式。
      Less是基于JavaScript，是在客户端处理的。
      Sass是基于Ruby的，是在服务器端处理的。
      关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。

2.js中的offset、scroll和client的区别
答：offsetTop,offsetLeft：获取离最近父容器的位置，如果没有父容器，那么获取离body最近的位置
      offsetWidth,offsetHeight：获取元素的大小，包括padding，border，内容。
      clientTop,clientLeft: 获取边框的高度和宽度
      clientWidth,clientHeight:获取元素的大小，只包括padding和内容
      scrollTop,scrollLeft:内容滚出去的距离
      screllWidth,screllHeight:不包括滚动条元素的“大小”（隐藏也算）

6月9日
--------------------------------------------------------------------------------------------------------------------------------------------
1. new操作符具体干了什么呢?
答：1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
      2、属性和方法被加入到 this 引用的对象中。
      3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。

2. dom事件委托什么原理，有什么优缺点
答：事件委托原理:事件冒泡机制
      优点：
      1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。
      2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适
      缺点：
      事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。

6月10日
--------------------------------------------------------------------------------------------------------------------------------------------
1.XSS（跨站脚本漏洞）原理及防范
答：Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者在论坛中放一个
      看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，
      当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。
      XSS防范方法：
      ①首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤；
      其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。
      这一个层面做好，至少可以堵住超过一半的XSS 攻击。
      ②首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
      其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。
      ③如果网站不需要在浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。
      ④尽量采用POST 而非GET 提交表单

6月11日
-------------------------------------------------------------------------------------------------------------------------------------------
1.$(this) 和 this 关键字在 jQuery 中有何不同？
答：$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。
      而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。
      你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。

2.JavaScript window.onload 事件和 jQuery ready 函数有何不同？
答：JavaScript window.onload 事件和 jQuery ready 函数之间的主要区别是：
      前者除了要等待 DOM 被创建还要等到包括大型图片、音频、视频在内的所有外部资源都完全加载。
      如果加载图片和媒体内容花费了大量时间，用户就会感受到定义在 window.onload 事件上的代码在执行时有明显的延迟。
      另一方面，jQuery ready() 函数只需对 DOM 树的等待，而无需对图像或外部资源加载的等待，从而执行起来更快。
      使用 jQuery $(document).ready() 的另一个优势是你可以在网页里多次使用它，浏览器会按它们在 HTML 页面里出现的顺序执行它们，
      相反对于 onload 技术而言，只能在单一函数里使用。鉴于这个好处，用 jQuery ready() 函数比用 JavaScript window.onload 事件要更好些。

6月12日
----------------------------------------------------------------------------------------------------------------------------------------------
1.git pull 和 git fetch 有什么区别？
答：git pull 命令从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支。
      git fetch 也用于相同的目的，但它的工作方式略有不同。当你执行 git fetch 时，它会从所需的分支中提取所有新提交，
   并将其存储在本地存储库中的新分支中。如果要在目标分支中反映这些更改，必须在 git fetch 之后执行git merge。
   只有在对目标分支和获取的分支进行合并后才会更新目标分支。git pull = git fetch + git merge

2.提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？
答：开发过程中，我们都有自己的特性分支，所以冲突发生的并不多，但也碰到过。
      诸如公共类的公共方法，我和别人同时修改同一个文件，他提交后我再提交就会报冲突的错误。
      发生冲突，在IDE里面一般都是对比本地文件和远程分支的文件，然后把远程分支上文件的内容手工修改到本地文件，
      然后再提交冲突的文件使其保证与远程分支的文件一致，这样才会消除冲突，然后再提交自己修改的部分。
      特别要注意下，修改本地冲突文件使其与远程仓库的文件保持一致后，需要提交后才能消除冲突，否则无法继续提交。必要时可与同事交流，消除冲突。

6月15日
-------------------------------------------------------------------------------------------------------------------------------------------
1.npm打包时需要注意哪些？如何利用webpack来更好的构建？
答：Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。 
      Npm模块需要注意以下问题：
            要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。
            Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。
            Npm包大小应该是尽量小（有些仓库会限制包大小）
            发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。
            UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。

2.webpack构建流程
答：3.1. 初始化参数，从配置文件和shell语句中读到的参数合并，得到最后的参数
      3.2. 开始编译：用合并得到的参数初始化complier对象，加载是所有配置的插件，执行run方法开始编译
      3.3. 确定入口，通过entry找到入口文件
      3.4. 编译模块，从入口文件出发，调用所有配置的loader对模块进行解析翻译，在找到该模块依赖的模块进行处理
      3.5. 完成模块编译，得到每个模块被翻译之后的最终的内容和依赖关系
      3.6. 输出资源，根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，在把每个chunk转换成一个单独的文件加载到输出列表
      3.7. 输出完成，确定输出的路径和文件名，把内容写到文件系统中
      在以上过程中，webpack会在特定的时间点广播出特定的事件，插件在舰艇感兴趣的事件后会执行特定的逻辑，改变webpack的运行结果


6月16日
-------------------------------------------------------------------------------------------------------------------------------------------
1、说说你对Promise的理解
依照 Promise/A+ 的定义，Promise 有四种状态：

    pending: 初始状态, 非 fulfilled 或 rejected.
    
    fulfilled: 成功的操作.
    
    rejected: 失败的操作.
    
    settled: Promise已被fulfilled或rejected，且不是pending
    另外， fulfilled 与 rejected 一起合称 settled。
    Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。

2、同步和异步的区别?
同步的概念应该是来自于操作系统中关于同步的概念:
不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式)。同步强调的是顺序性，谁先谁后；异步则不存在这种顺序性。

同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。

异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。

3、 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？
同样是基于入口的打包工具还有以下几个主流的：

webpack
rollup
parcel
从应用场景上来看：

webpack适用于大型复杂的前端站点构建
rollup适用于基础库的打包，如vue、react
parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果
由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel

4、有哪些常见的Loader？他们是解决什么问题的？
file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件
url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去
source-map-loader：加载额外的 Source Map 文件，以方便断点调试
image-loader：加载并且压缩图片文件
babel-loader：把 ES6 转换成 ES5
css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。
eslint-loader：通过 ESLint 检查 JavaScript 代码

5、对于面向对象的理解
a)Javascript是一种基于对象的语言，在程序中遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class类
b)在js中使用面向对象可以通过构造函数，所谓"构造函数"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上
c)使编程的注意力重新从应用程序的逻辑回到其数据上来。换句话说，OOP将焦点从过程式编程转向最终建模的真实实体。这使得应用程序更接近我们周围的现实世界。
d)OOP达到了软件工程的三个目标：重用性、灵活性和扩展性。 采用面向对象方法可以使系统各部分各司其职、各尽所能; 使其编程的代码更简洁、更易于维护，并且具有更强的可重用性

6、栈和堆的区别?
栈区(stack) ：一般由编译器自 动分配释放， 存放函数的参数值，局部变量的值等。
堆区(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。
堆(数据结构) :堆可以被看成是一棵树，如:堆排序;
栈(数据结构) :一种先进后出的数据结构。


6月17日
------------------------------------------------------------------------------------------------------------------------------
1.一次完整的HTTP事务是怎样一个过程？
a.域名解析
b.发起TCP的三次握手
c.建立TCP连接后发起http请求
d.服务器端响应http请求，浏览器得到html码
e.浏览器解析html代码，并请求html代码中的资源
f.浏览器对页面进行渲染并呈现给客户

2.vue优点？
（1）轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；
（2）简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
（3）双向数据绑定：保留了angular的特点，在数据操作方面更为简单；
（4）组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；
（5）视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
（6）虚拟DOM：dom操作是非常耗费性能的， 不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；
（7）运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。

3.v-show和v-if指令的共同点和不同点？
共同点：都能控制元素的显示和隐藏；
不同点：实现本质方法不同，
v-show 通过样式display显示与隐藏，特点：初始化性能消耗，如果永久隐藏不推荐使用
v-if 移除标签添加标签, 特点：每次重新删除与添加元素，消耗性能，频繁切换效果不推荐使用

4.Vue组件间的参数传递
1.父组件与子组件传值
父组件传给子组件：子组件通过props方法接受数据;
子组件传给父组件：$emit方法传递参数
2.非父子组件间的数据传递，兄弟组件传值
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。

5,请描述一下 cookies，sessionStorage 和 localStorage 的区别？
（1）cookie在浏览器和服务器间来回传递， sessionStorage和localStorage不会。
（2）sessionStorage和localStorage的存储空间更大。
（3）sessionStorage和localStorage有更多丰富易用的接口。
（4）sessionStorage和localStorage各自独立的存储空间。

6.性能优化的方法？
（1）减少DOM操作
最小化DOM访问次数，尽量缓存访问DOM的样式信息，避免过度触发回流；
如果在一个局部方法中需要多次访问同一个dom，则先暂存它的引用。
（2）采用更优的API替代消费高的api，转换优化消费高的集合
    ①用 All()替代getElementByXX()；②开启动画的GPU加速，把渲染计算交给GPU；③少用HTML集合（类数组）来遍历，因为集合遍历比真数组遍历耗费更高；④用事件委托来减少事件处理器的数量
（3）减少重排
     ①避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性；②实现元素的动画，它的position属性，最好是设为absoulte或fixed，这样不会影响其他元素的布局；③动画实现的速度的选择。比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多；④不要使用table布局，因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围
（4）css及动画处理
       ①少用css表达式；②减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；③动画尽量使用在绝对定位或固定定位的元素上；④隐藏在屏幕外，或在页面滚动时，尽量停止动画；

6月18日
------------------------------------------------------------------------------------------------------------------------------
1.vue中双向数据绑定是如何实现的？
    vue双向绑定是通过数据劫持结合发布订阅者模式的方式来实现的，也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；
    核心：关于VUE双向数据绑定，其核心是Object.defineProperty()方法。

2.AJAX的流程是什么？
	1.客户端产生js的事件
	2.创建XMLHttpRequest对象
	3.对XMLHttpRequest进行配置
	4.通过AJAX引擎发送异步请求
	5.服务器端接收请求并且处理请求，返回html或者xml内容
	6.XML调用一个callback()处理响应回来的内容
	7.页面局部刷新

3.Vue 事件绑定原理
    理解：
        Vue 事件绑定分为两种：一是原生事件的绑定；二是组件的事件绑定。
        原生dom事件绑定用 addEventListener 实现（普通元素的@click 与组件的@click.native）
        组件自定义事件绑定采用 $on 方法实现 ，可用event触发（组件的@click 单独处理）

4.常用的ES6新特性有哪些？
    ECMAScript 6(ES6) 目前基本成为业界标准，它的普及速度比 ES5 要快很多，主要原因是现代浏览器对 ES6的支持相当迅速，尤其是 Chrome 和 Firefox 浏览器，已经支持 ES6 中绝大多数的特性。
    ①.不一样的变量声明：const和let
    ES6推荐使用let声明局部变量；（用var声明变量，无论声明在何处，都会被视为声明在函数的最顶部）
let表示声明变量，let 关键词声明的变量不具备变量提升（hoisting）特性。
    而const表示声明常量，两者都为块级作用域，let 和 const 声明只在最靠近的一个块中（花括号内）有效。const 声明的变量都会被认为是常量，意思就是它的值被设置完成后就不能再修改了；如果const的是一个对象，对象所包含的值是可以被修改的。const 在声明时必须被赋值
    ②.模板字符串
    在ES6之前，我们往往：通过“\”和“+”来构建处理模板字符串
    ES6反引号(``)直接搞定；
    ③.箭头函数
    ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =>，紧接着是函数体；
    箭头函数最直观的三个特点：
        不需要 function 关键字来创建函数
        省略 return 关键字
        继承当前上下文的 this 关键字

5.你对Ajax的理解。
    1.AJAX 是一种用于创建更好更快以及交互性更强的 Web 应用程序的技术；
    2.通过Ajax你的 JavaScript 可在不重载页面的情况与 Web 服务器交换数据；  
    3.AJAX 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面；
    4.AJAX 可使因特网应用程序更小、更快，更友好；
    5.AJAX 是一种独立于 Web 服务器软件的浏览器技术。

6.mvvm 框架是什么？
    答：vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View

6.19
------------------------------------------------------------------
1. 什么是vue的计算属性？
答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：①使得数据处理结构清晰；②依赖于数据，数据更新，处理结果自动更新；③计算属性内部this指向vm实例；④在template调用时，直接写计算属性名即可；⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。

2. vue中data的属性可以和methods中的方法同名吗？为什么？
答：不可以
因为，Vue会把methods和data的东西，全部代理到Vue生成的对象中，会产生覆盖所以最好不要同名


3. vue组件中data为什么必须是一个函数？
答：因为JavaScript的特性所导致，在component中，data必须以函数的形式存在，不可以是对象。
　　组建中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个data，这样改一个全都改了。


4. vue和jQuery的区别
答：jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$("lable").val();,它还是依赖DOM元素的值。
Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。


5. 计算属性与函数的区别：
vue的methods方法是无缓存的，计算属性有缓存；vue直接调用methods方法，该方法将会重新计算；调用计算属性时，计算属性首先检查依赖是否改变，如果依赖没有改变，计算属性不会重新计算而是直接返回之前缓存的值。

6. vue等单页面应用及其优缺点
答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。
缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。

6.20
------------------------------------------------------------------
1.vue父子组件是如何通讯的?

	1) 数据流只能是父组件单向流向子组件;

	2) 子组件依赖属性绑定方式关联父组件传递的数据模型;

	3) 子组件不能直接反向修改父组件的数据模型;

	4) 若子组件需要修改父组件的数据模型，子组件需要触发一个自定义事件通知父组件主动修改           自身的数据模型;

	5) 父组件的数据模型可以同时被多个子组件关联引用;
	
	6) 只要父组件主动修改了数据模型, 与之关联的子组件的属性绑定值也会随之变化;

2.什么是 vue 生命周期？有什么作用？
答：每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会。（ps：生命周期钩子就是生命周期函数）例如，如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗， 那我们最早可在mounted 中进行。

3.vue中 key 值的作用：

    使用key来给每个节点做一个唯一标识
    key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。


4.vue.js的两个核心是什么(数据驱动、组件系统。)
数据驱动:Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制,核心是VM，即ViewModel，保证数据和视图的一致性。

5.vue常用的修饰符
.stop：等同于JavaScript中的event.stopPropagation()，防止事件冒泡；
.prevent：等同于JavaScript中的event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；
.capture：与事件冒泡的方向相反，事件捕获由外到内；
.self：只会触发自己范围内的事件，不包含子元素；
.once：只会触发一次。

6. computed 和 watched 的区别：
computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。例子：购物车

watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。
所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。 例子：搜索数据

6.22
------------------------------------------------------------------
1. 如何让CSS只在当前组件中起作用?
将当前组件的<style>修改为<style scoped>

2. 组件中 data 为什么是函数?
为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？
因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。

3. slot插槽
当子组件模板只有一个没有属性的插槽时，父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。
最初在 <slot> 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。

4. 请说下封装 vue 组件的过程？
1. 建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑　　
2. 准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。
3. 准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。
4. 封装完毕了，直接调用即可

5. 为什么避免 v-if 和 v-for 用在一起？
当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。

6. $route和 $router的区别是什么？
$router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。
$route 是路由信息对象，跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数。

6.23
------------------------------------------------------------------
1.vue-router有哪几种导航钩子？
① 全局前置守卫：router.beforeEach((to, from, next) => {})，作用：跳转前进行判断拦截
② 全局解析守卫：router.beforeResolve((to, from, next) => {})，作用：和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用
③ 全局后置钩子：router.afterEach((to, from) => {})，作用：和beforeEach相反，它是在路由跳转完成之后触发，参数包括to、from，没有了next，它发生在beforeEach和beforeResolve之后，beforeRouteEnter之前
④ 路由独享的守卫：router.beforeEnter((to, from, next) => {})，作用：和beforeEach完全相同，如果都设置则在beforeEach之后紧随执行，参数有to、from、next
⑤ 组件内的守卫：beforeRouteEnter、beforeRouteUpdate 、beforeRouteLeave。三个守卫的参数都有to、from、next，区别是beforeRouteEnter守卫不能获取组件实例this，另外两个守卫可以访问this

2、Vue路由哈希设置哈希配置和h5的history配置的区别？
① 直观区别：hash模式url带#号，history模式不带#号。
② 深层区别：hash模式url里面永远带着#号，我们在开发当中默认使用这个模式。如果用户考虑url的规范，那么就需要使用history模式，因为history模式没有#号，是个正常的url，适合推广宣传。功能也有区别，比如我们在开发app的时候有分享页面，那么这个分享出去的页面就是用vue或是react做的，我们把这个页面分享到第三方的app里，有的app里面url是不允许带有#号的，所以要将#号去除，这时候就要使用history模式。但是使用history模式还有一个问题就是，在访问二级页面的时候，做刷新操作，会出现404错误，那么就需要和后端人配合让他配置一下apache或是nginx的url重定向，重定向到你的首页路由上

3、vue中params与query区别？
① query更加类似于ajax中的get传参，params则类似于post，说的再简单一点就是，前者在浏览器地址栏中显示参数，后者则不显示
② query要用path来引入，params要用name来引入，接收参数都是类似的
③ 当刷新页面后params中的数据就没有了，而query则不会

4、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？
定义vue-router的动态路由：在router目录下的index.js文件中，对path属性加上/:id
获取传递的动态参数：使用router对象的params.id，例如 :  this.$route.params.id

5、vue如何实现按需加载配合webpack设置？
webpack中提供了require.ensure()来实现按需加载。
以前引入路由是通过import 这样的方式引入，现在改为const定义的方式进行引入。
不进行页面按需加载引入方式：import home from '../../common/home.vue'
进行页面按需加载的引入方式：const home = r => require.ensure( [], () => r (require('../../common/home.vue')))

6、vue路由之间跳转的两种方式？
① 声明式（通过router-link实现跳转）：<router-link :to="...">
② 编程式（使用js编程的方式进行页面跳转）：this.$router.push(...)

6.24
------------------------------------------------------------------
1、Vue-router跳转和location.href有什么区别
答：使用location.href='/url'来跳转，简单方便，但是刷新了页面；
使用history.pushState('/url')，无刷新页面，静态跳转；
引进router，然后使用router.push('/url')来跳转，使用了diff算法，实现了按需加载，减少了dom的消耗。
其实使用router跳转和使用history.pushState()没什么差别的，因为vue-router就是用了history.pushState()，尤其是在history模式下。

2、params和query的区别
答：用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。
url地址显示：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示
注意点：query刷新不会丢失query里面的数据
params刷新 会 丢失 params里面的数据。

3、什么是 vue 生命周期？有什么作用？
答：每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。
同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会。（ps：生命周期钩子就是生命周期函数）
例如，如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗， 那我们最早可在mounted 中进行。

4、$route 和 $router 的区别
答：$router是VueRouter的实例，在script标签中想要导航到不同的URL,使用$router.push方法。返回上一个历史history用$router.to(-1)
$route为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。

5、vue-router的两种模式
答:hash模式：即地址栏 URL 中的 # 符号；
history模式：window.history对象打印出来可以看到里边提供的方法和记录长度。
利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）。

6、vue-router 有哪几种导航钩子?
答：三种，
第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
第二种：组件内的钩子
第三种：单独路由独享组件

6.28
------------------------------------------------------------------
1、vuex的Getter特性是？vuex的优势？
getter用来获取数据，mapgetter经常在计算属性中被使用

vuex的优势：
1)状态管理工具 核心是响应式的数据管理
2)一个页面发生数据变化。动态的改变对应的页面
3)相比使用localStorage ,localstorge只能纯属字符串数据格式，因此还得封装自己的写入写出，localstorage的优势是永久存储。
兄弟组件之间有大量通信的，建议一定要用VUEX，不管大项目和小项目


2、Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？
判断请求来的数据是不是要被其他组件公用，如果仅仅在请求的组件内使用，就不需要放入vuex的state里
如果被其他地方复用，这个很大几率上时需要的，如果需要，请将请求放入action里，方便复用

3、vuex有哪几种属性？
答：有五种，分别是 State、 Getter、Mutation 、Action、 Module
state => 基本数据(数据源存放地) => 类似于组件的data
getters => 从基本数据派生出来的数据 => 类似于组件的computed
mutations => 提交更改数据的方法，同步 => 类似于组件的methods
actions => 像一个装饰器，包裹mutations，使之可以异步 => 提交mutations
modules => 模块化Vuex => 可以实现多层嵌套

4、$nextTick的使用
答：当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，
你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功。

5、为什么要用vuex？
由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。所以我们需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。

6、Vuex概念理解性：  
Vuex采用MVC模式中的Model层，规定所有的数据必须通过action--->mutaion--->state这个流程进行来改变状态的。再结合Vue的数据视图双向绑定实现页面的更新。统一页面状态管理，可以让复杂的组件交互变的简单清晰，同时在调试时也可以通过DEVtools去查看状态。

6.29
------------------------------------------------------------------
1.vuex的State特性是？
     state就是存放数据的地方，类似一个仓库  
      特性就是当mutation修改了state的数据的时候，他会动态的去修改所有的调用这个变量的所有组件里面的值（若是store中的数据发生改变，依赖这个数据的组件也会发生更新）

2.Vuex中action和mutation有什么区别？
action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态。
action 可以包含任意异步操作。mutation只能是同步操作。
提交方式不同，action 是用this.$store.dispatch('ACTION_NAME',data)来提交。mutation是用this.$store.commit('SET_NUMBER',10)来提交。
接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了state,      // 等同于 `store.state`，若在模块中则为局部状态
    rootState,  // 等同于 `store.state`，只存在于模块中
    commit,     // 等同于 `store.commit`
    dispatch,   // 等同于 `store.dispatch`
    getters,    // 等同于 `store.getters`
    rootGetters // 等同于 `store.getters`，只存在于模块中

3.在模块中，getter和mutation和action中怎么访问全局的state和getter？

在getter中可以通过第三个参数rootState访问到全局的state,可以通过第四个参数rootGetters访问到全局的getter。
在mutation中不可以访问全局的state和getter，只能访问到局部的state。
在action中第一个参数context中的context.rootState访问到全局的state，context.rootGetters访问到全局的getter。

4.你有使用过vuex的module吗？主要是在什么场景下使用？
我们使用vuex 需要实例化一个Vuex的Store构造函数。  modules 中则是我们自定义注册的module. 每个module 中都有自己独立的state, action, mutation, getter...  。通过它来区分更新/调用 对应的vuex 方法来隔离未知数据更新等数据相关问题。

5.为什么要使用Vuex模块,怎么使用
因为使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。所以将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块，从上至下进行同样方式的分割。

6.页面刷新后vuex的state数据丢失怎么解决？

一种是state里的数据全部是通过请求来触发action或mutation来改变(基本不可行，除非项目很小或者vuex存储的数据很少)

另一种是将state里的数据保存一份到本地存储(localStorage、sessionStorage、cookie）中

而第二种可以保证刷新页面数据不丢失且易于读取。

 //在页面加载时读取sessionStorage里的状态信息

//在页面刷新时将vuex里的信息保存到sessionStorage里


6.30
------------------------------------------------------------------

1、用过Vuex模块的命名空间吗？为什么使用，怎么使用？
默认情况下，模块内部的action、mutation和getter是注册在全局命名空间，如果多个模块中action、mutation的命名是一样的，那么提交mutation、action时，将会触发所有模块中命名相同的mutation、action，这样有太多的耦合，如果要使你的模块具有更高的封装度和复用性，你可以通过添加namespaced: true 的方式使其成为带命名空间的模块。

2、vue-router实现路由懒加载（动态加载路由）三种方式
第一种：vue异步组件技术===异步加载，vue-router配置路由，使用vue的异步组件技术，可以实现按需加载。但是这种情况下一个组件生成一个js文件
第二种：路由懒加载（使用import）
第三种：webpack提供的require.ensure(),vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件

3、vue组件中data为什么必须是一个函数？
答：因为JavaScript的特性所导致，在component中，data必须以函数的形式存在，不可以是对象。
　　组件
.中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个data，这样改一个全都改了。

4、箭头函数与普通函数function的区别
答：箭头函数是匿名函数，不能作为构造函数，不能使用new
箭头函数不绑定arguments，取而代之用rest参数...解决
箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。
箭头函数没有原型属性
箭头函数不能当做Generator函数,不能使用yield关键字

5、为什么使用key？
当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。

6、组件化和模块化的区别
组件：最初的目的是代码重用，功能相对单一或者独立。在整个系统的代码层次上位于最底层，被其他代码所依赖，所以说组件化是纵向分层。
模块：最初的目的是将同一类型的代码整合在一起，所以模块的功能相对复杂，但都同属于一个业务。不同模块之间也会存在依赖关系，但大部分都是业务性的互相跳转，从地位上来说它们都是平级的。

07.01
---------------------------------------------------------------------------------------------------------------------------------------------------
1.用过哪些设计模式？
（1）工厂模式：
主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。
将所有实例化的代码集中在一个位置防止代码重复。工厂模式解决了重复实例化的问题 ，
但还有一个问题,那就是识别问题，因为根本无法搞清楚他们到底是哪个对象的实例。
(:例子不用背诵 ，意在帮助理解
    function createObject(name,age,profession){//集中实例化的函数var obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.profession = profession;
        obj.move = function () {
            return this.name + ' at ' + this.age + ' engaged in ' + this.profession;
        };
        return obj;
    }
    var test1 = createObject('trigkit4',22,'programmer');//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例
)
（2）构造函数模式
使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于：
A构造函数方法没有显式的创建对象 (new Object());B.直接将属性和方法赋值给this对象;C.没有 renturn 语句。


2 HTTP和HTTPS？为什么HTTPS安全?
（1）HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。
（2）HTTP的默认端口号为80，HTTPS的默认端口号是443。
（3）因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。
        https之所以比http安全，是因为他利用ssl/tsl协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。
       保障了传输过程的安全性。


3.Javascript垃圾回收方法?
（1）标记清除（mark and sweep）
这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，
当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。
垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），
在这些完成之后仍存在标记的就是要删除的变量了。

（2）引用计数(reference counting)
在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。
引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，
如果该变量的值变成了另外一个，则这个值的引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，
因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。

在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 
也就是说只要涉及BOM及DOM就会出现循环引用问题。

4.Vue属性响应式的监听原理：
在Vue实例化时通过Object.defineProperty()方法在每一个属性上直接添加get和set方法与当前属性进行绑定。
当这些响应式属性发生改变时会触发他们的set方法从而告知vue引起页面的更新;但是js中数据类型分为两种基本数据类型,引用数据类型.
vue在监听引用数据类型的改变时,只能检测到他们内存地址是否发生改变；以数组为例 vm.arr[i] =  newValue 检测不到的, 
vm.arr = newArr 可以检测(旧数组与新数组内存地址不同,可以通过用新数组覆盖的方法引起vue检测);vue为了方便开发者开发,
数组以下api方法Vue可以监听其变化
5，简单描述每个周期具体适合哪些场景
beforecreate : 可以在这加个loading事件，在加载实例时触发
created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
mounted : 挂载元素，获取到DOM节点
updated : 如果对数据统一处理，在这里写上相应函数
beforeDestroy : 可以做一个确认停止事件的确认框
nextTick : 更新数据后立即操作dom

6、<keep-alive> </keep-alive>的作用是什么?
包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。

07.02
---------------------------------------------------------------------------------------------------------------------------------------------------
1.怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？
通过让getter返回一个函数，来实现给getter传参。然后通过参数来进行判断从而获取state中满足要求的状态。

2.vuex是什么？怎么使用？哪种功能场景使用它？
答：vue框架中状态管理。在main.js引入store，注入。
新建了一个目录store.js，….. export 。
场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

3.Vue中引入组件的步骤?
1）采用ES6的import ... from ...语法或CommonJS的require()方法引入组件
2）对组件进行注册
3）使用组件<my-component></my-component>

4.vue-loader是什么？使用它的用途有哪些？
vue-loader是解析.vue文件的一个加载器。
用途：js可以写es6、style样式可以scss或less、template可以加jade等

5.VNode是什么？虚拟 DOM是什么?
Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。

6.请说出vue.cli项目中src目录每个文件夹和文件的用法？

答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件

07.03
---------------------------------------------------------------------------------------------------------------------------------------------------

1、axios 特点

1. 基于 promise 的异步 ajax 请求库，支持promise所有的API
2. 浏览器端 / node 端都可以使用，浏览器中创建XMLHttpRequests
3. 支持请求／响应拦截器
4. 支持请求取消
5. 可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据
6. 批量发送多个请求
7. 安全性更高，客户端支持防御 XSRF，就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。

2、Vue中是如何检测数组变化? 
理解: 
使用函数劫持的方式，重写了数组的方法 Vue 将 data 中的数组，进行了原型链重写。指向了自己定义的数组原型方法，这样当调用数组 api 时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控。

3、params和query的区别
答：用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。
url地址显示：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示
注意点：query刷新不会丢失query里面的数据
params刷新 会 丢失 params里面的数据。

4、calc、support、media各自的含义及用法？
①@support主要是用于检测浏览器是否支持CSS的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。
②calc() 函数用于动态计算长度值。 calc()函数支持 "+"、 "-"、"*"、 "/" 运算；
③@media 查询，可以针对不同的媒体类型(比如不同尺寸大小的屏幕显示)定义不同的样式。

5、分别简述computed和watch的使用场景
答：
     computed:
　　　　当一个属性受多个属性影响的时候就需要用到computed
　　　　例子： 购物车商品结算的时候
     watch:
　　　　当一条数据影响多条数据的时候就需要用watch
　　　　例子：搜索数据

6、什么是jsonp，jsonp的实现步骤是什么
jsonp是json的一种使用模式，可用于解决主流浏览器的跨域数据访问的问题
jsonp实现原理：利用script标签不受同源策略限制的特点，实现跨域请求
jsonp实现步骤：
    创建一个script
    将请求地址赋值给script的src属性
    将后台约定回调函数名称以参数的形式挂在请求地址中
    将一个全局函数作为后台约定回调函数的值
    后台响应的数据在全部函数中处理

07.06
-------------------------------------------------------------------------------------------------------------
1、vue项目优化解决方案
1.使用mini-css-extract-plugin插件抽离css
2.配置 optimization 把公共的js代码抽离出来
3.通过 Webpack 处理文件压缩
4.不打包框架、库文件，通过cdn的方式引入
5.小图片使用 base64
6.配置项目文件懒加载
7.UI 库配置按需加载
8.开启 Gzip压缩

2、vue为什么要求组件模版只能有一个根结点
因为vue组件最终是要被各种loader打包解析的，而我们必须为loader指定一个入口。而且，模版最终是会被编译成vdom的，所以必须有一个根结点来递归遍历其子节点，渲染成一个“树”。

3、子组件向父组件传值的方法？
子组件向父组件传值用 this.$emit(key,value) ，父组件接收的时候需要在父组件中创建的子组件的标签中绑定 Key，格式:@Key=“方法名”，父组件声明这个方法，方法带参数，这个参数就是子组件传递的 Value。

4、created和mounted的区别
答：created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

5、vue常用的修饰符
答：.stop：等同于JavaScript中的event.stopPropagation()，防止事件冒泡；
.prevent：等同于JavaScript中的event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；
.capture：与事件冒泡的方向相反，事件捕获由外到内；
.self：只会触发自己范围内的事件，不包含子元素；
.once：只会触发一次。

6、params和query的区别
答：用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。
url地址显示：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示
注意点：query刷新不会丢失query里面的数据
params刷新 会 丢失 params里面的数据。

07.07
-------------------------------------------------------------------------------------------------------------

1.import和export
答：ES6标准中，JavaScript原生支持模块(module)了。这种将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中,各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。
      export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口。
      import用于在一个模块中加载另一个含有export接口的模块。
      import和export命令只能在模块的顶部，不能在代码块之中。

2.localStorage: localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。
sessionStorage:sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。
cookie:cookie生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右,有个数限制（各浏览器不同），一般不能超过20个。缺点是不能储存大数据且不易读取。


3.vue中key值的作用?
答:当Vue.js用v-for正在更新已渲染过的元素列表时,它默认用”就地复用"策略。如果数据项的顺序被
改变，Vue 将不会移动DOM元愫来匹配数据项的顺序，而是简单 复用此处每个元素,并且确保它在特
定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。

4.$route和$router的区别
答: $route是 路由信息对象”，包括path, params, hash, query, fullPath, matched, name等路由信
息参数。而$router是 ”路由实例"对象包括了路由的跳转方法,钩子函数等。

5.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？
答：判断请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。
如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。

6.vuex有哪几种属性？
答：有五种，分别是 State、 Getter、Mutation 、Action、 Module
state => 基本数据(数据源存放地)
getters => 从基本数据派生出来的数据
mutations => 提交更改数据的方法，同步！
actions => 像一个装饰器，包裹mutations，使之可以异步。
modules => 模块化Vuex

07.08
-------------------------------------------------------------------------------------------------------------
1.组件通信
父传子用props,父用子用ref 子调父用$emit,无关系用Bus.
Vuex组件通信库，可以避免子组件无法改变props的弊端等 mutations 同步操作， 用于改变状态 官方不推荐异步 action 执行多个mutaions，官方推荐异步操作 mapState、mapGetters、mapActions使用示例

2.computed watch methods的用法与区别
1.前两者自动追踪数据，执行相关函数，最后一个手动调用；
2.computed是计算属性，用法与data一致
3.watch像事件监听，对象发生变化时，执行相关操作
4.methods与js中执行方法类似
5.computed通常只有get属性
6.数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择
7.watch的对象必须事先声明

3.nextTick的实现原理
在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用
Promise
MutationObserver
setImmediate
如果以上都不行则采用setTimeout
定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列

4.怎么定义组件
答案：
​ 全局定义：Vue.component(组件名, {template: 模板字符串})
​ 局部定义：components:{组件名: {template: 模板字符串}}
​ 单文件组件：包含template，script，style三部分

5.在vue中获取dom元素
​ 在vue中可以通过给标签加ref属性，就可以在js中利用$refs去引用它，从而操作该dom元素

6.slot是什么
​ 插槽：
​ 三种方式：1、匿名插槽
​ 2、具名插槽
​ 3、带参数的插槽

07.09
-------------------------------------------------------------------------------------------------------------
1. vue获取数据在哪个周期函数
答：一般 created/beforeMount/mounted 皆可.
比如如果你要操作 DOM , 那肯定 mounted 时候才能操作.

2. 第一次页面加载会触发哪几个钩子
答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子

3.axios是什么？怎么使用？描述使用它实现登录功能的流程？

答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。
后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中

4. defer和async的区别

defer并行加载js文件，会按照页面上script标签的顺序执行 

async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行

5. 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？
因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。

6. 怎样理解单向数据流这个概念出现在组件通信。
父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。
子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。
一般来说，对于子组件想要更改父组件状态的场景，可以有两种方案：在子组件的 data 中拷贝一份 prop，data 是可以修改的，但 prop 不能。

07.10
-------------------------------------------------------------------------------------------------------------
1、vue初始化页面闪动问题如何解决？
使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样
解决方法：在css里加上[v-cloak] {display: none;}。如果没有彻底解决问题，则在根元素加上style="display: none;" :style="{display: 'block'}"

2、Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？
Vue路由在Android机上有问题，是babel问题引起的，安装babel polypill插件可以解决

3、单页面应用和多页面应用区别
① 单页面应用（SPA）：通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。
所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，
单页面的页面跳转，仅刷新局部资源。多应用于pc端
② 多页面（MPA）：就是指一个应用中有多个页面，页面跳转时是整页刷新

4、vue等单页面应用的优缺点
① 单页面的优点：用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）
② 单页面的缺点：不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。
（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；
初次加载时耗时多；页面复杂度提高很多

4、active-class 是哪个组件的属性？
vue-router 模块的 router-link 组件

5、不用 vuex 会带来什么问题
①可维护性会下降，你要修改数据，你得维护 3 个地方
②可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的
③增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背

07.13
-------------------------------------------------------------------------------------------------------------------------------------------------------

1、简单描述下微信小程序的相关文件类型？
答：微信小程序项目结构主要有四个文件类型,如下：
WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。
内部主要是微信自己定义的一套组件。
WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，
js 逻辑处理，网络请求  json 小程序设置，如页面注册，页面标题及tabBar。

2、你是怎么封装微信小程序的数据请求的？
(1)、将所有的接口放在统一的js文件中并导出
(2)、在app.js中创建封装请求数据的方法
(3)、在子页面中调用封装的方法请求数据

3、有哪些参数传值的方法？
(1)、给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或onload的param参数获取。
        但data-名称不能有大写字母和不可以存放对象
(2)、设置id 的方法标识来传值通过e.currentTarget.id获取设置的id的值,然后通过设置全局对象的方式来传递数值
(3)、在navigator中添加参数传值

4、你使用过哪些方法，来提高微信小程序的应用速度？
(1)、提高页面加载速度
(2)、用户行为预测
(3)、减少默认data的大小
(4)、组件化方案

5、分析下微信小程序的优劣势？
答：优势：
(1)、无需下载，通过搜索和扫一扫就可以打开。
(2)、良好的用户体验：打开速度快。
(3)、开发成本要比App要低。
(4)、安卓上可以添加到桌面，与原生App差不多。
(5)、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序是无法发布到线上的。
劣势：
(1)、限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。
(2)、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。
(3)、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。
(4)、依托于微信，无法开发后台管理功能。

6、微信小程序与H5的区别？
答：
(1)运行环境的不同
    传统的HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核
    完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。
(2)开发成本的不同
    只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG
(3)获取系统级权限的不同
    系统级权限都可以和微信小程序无缝衔接
(4)应用在生产环境的运行流畅度
    长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。
    但是由于微信小程序运行环境独立

07.15
-------------------------------------------------------------------------------------------------------------------------------------------------------
1、小程序和Vue写法的区别？
答：
一、循环遍历的时候：小程序是wx:for="list"，而Vue是v-for="info in list"
二、调用data模型的时候：小程序是this.data.uinfo，而Vue是this.uinfo；给模型赋值也不一样，小程序是this.setData({uinfo:1})，而Vue是直接this.uinfo=1
2、如何实现下拉刷新
首先在全局 config 中的 window 配置 enablePullDownRefresh
在 Page 中定义 onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法
请求返回后，调用 wx.stopPullDownRefresh 停止下拉刷新
3、简述下 wx.navigateTo(), wx.redirectTo(),wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别 
wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面
wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面
wx.switchTab()：跳转到 abBar 页面，并关闭其他所有非 tabBar 页面
wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层
wx.reLaunch()：关闭所有页面，打开到应用内的某个页面
4、bindtap和catchtap的区别是什么
相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分
不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的
5、性能优化的方法？
（1）减少DOM操作
最小化DOM访问次数，尽量缓存访问DOM的样式信息，避免过度触发回流；
如果在一个局部方法中需要多次访问同一个dom，则先暂存它的引用。
（2）采用更优的API替代消费高的api，转换优化消费高的集合
    ①用 All()替代getElementByXX()；②开启动画的GPU加速，把渲染计算交给GPU；③少用HTML集合（类数组）来遍历，因为集合遍历比真数组遍历耗费更高；④用事件委托来减少事件处理器的数量
（3）减少重排
     ①避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性；②实现元素的动画，它的position属性，最好是设为absoulte或fixed，这样不会影响其他元素的布局；③动画实现的速度的选择。比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多；④不要使用table布局，因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围
（4）css及动画处理
       ①少用css表达式；②减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；③动画尽量使用在绝对定位或固定定位的元素上；④隐藏在屏幕外，或在页面滚动时，尽量停止动画；
6、请谈谈小程序的生命周期函数？
onLoad() 页面加载时触发，只会调用一次，可获取当前页面路径中的参数。
onShow() 页面显示/切入前台时触发，一般用来发送数据请求；
onReady() 页面初次渲染完成时触发, 只会调用一次，代表页面已可和视图层进行交互。
onHide() 页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小程序切入后台等。
onUnload() 页面卸载时触发，如redirectTo或navigateBack到其他页面时。
onPullDownRefresh() 下拉刷新的钩子函数 用户下拉刷新时会自动走到这个函数中
onReachBottom() 上翻到底的钩子函数


07.17
-------------------------------------------------------------------------------------------------------------------------------------------------------
1.小程序对wx:if 和 hidden使用的理解？
wx:if 有更高的切换消耗。
hidden 有更高的初始渲染消耗。
因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。


2.简述微信小程序原理？
小程序本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口；
它的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现；
它从技术讲和现有的前端开发差不多，采用JavaScript、WXML、WXSS三种技术进行开发；
功能可分为webview和appService两个部分；
webview用来展现UI，appService有来处理业务逻辑、数据及接口调用；
两个部分在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理等。


3.分析微信小程序的优劣势？
优势：
1.容易上手，基础组件库比较全，基本上不需要考虑兼容问题；
2.开发文档比较完善，开发社区比较活跃，支持插件式开发；
3.良好的用户体验：无需下载，通过搜索和扫一扫就可以打开，打开速度快，安卓上可以添加到桌面，与原生APP差不多；
4.开发成本比APP要低；
5.为用户提供良好的安全保障（小程序发布 严格的审查流程）
劣势：
1.限制较多，页面大小不能超过1M，不能打开超过5个层级的页面；
2.样式单一，部分组件已经是成型了的，样式不可修改，例如：幻灯片、导航
3.推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广
4.依托于微信，无法开发后台管理功能
5.后台调试麻烦，因为api接口必须https请求且公网地址
6.真机测试，个别功能安卓和苹果表现迥异，例如安卓的定位功能加载很慢


4. 请谈谈小程序的生命周期函数？
onLoad() 页面加载时触发，只会调用一次，可获取当前页面路径中的参数。
onShow() 页面显示/切入前台时触发，一般用来发送数据请求；
onReady() 页面初次渲染完成时触发, 只会调用一次，代表页面已可和视图层进行交互。
onHide() 页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小程序切入后台等。
onUnload() 页面卸载时触发，如redirectTo或navigateBack到其他页面时。

5.你是怎么封装微信小程序的数据请求的？
在根目录下创建utils目录及api.js文件和apiConfig.js文件；
在apiConfig.js 封装基础的get, post 和 put， upload等请求方法，设置请求体，带上token和异常处理等；
在api中引入apiConfig.js封装好的请求方法，根据页面数据请求的urls, 设置对应的方法并导出；
在具体的页面中导入；


6. 简单描述下微信小程序的相关文件类型
微信小程序项目结构主要有四个文件类型
WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件
WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式
js 逻辑处理，网络请求
json 小程序设置，如页面注册，页面标题及tabBar


1.ajax标准写法
$.ajax({
    url:"http://www.microsoft.com",    //请求的url地址
    dataType:"json",   //返回格式为json
    async:true,//请求是否异步，默认为异步，这也是ajax重要特性
    data:{"id":"value"},    //参数值
    type:"GET",   //请求方式
    beforeSend:function(){
        //请求前的处理
    },
    success:function(req){
        //请求成功时处理
    },
    complete:function(){
        //请求完成的处理
    },
    error:function(){
        //请求出错处理
    }
})

2.jq函数
$(document).ready(function(){
  $("button").click(function(){
  $(this).hide();
 });
});